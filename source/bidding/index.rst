
Guardnode functionality
=========================

Proposed design for Guardnode functionality in the Ocean client. 

Requests
^^^^^^^^

Requests in the guardnode system must be permissioned (i.e. only authorised partners - client chains - can issue requests). Permission tokens are required to issue requests.
This works as follows:
Permission tokens (\ ``permissionAsset``\ ) are (optionally) issued to a given address in the genesis block, e.g.:

'permissionassetcoins=5000000'
'permissionassetdestination=g4e638a7cc43....'' (the scriptPubKey of the permissionasset output).

This scriptPubKey (multisig or P2PKH) is owned by the 'controller'. The controller sends a quantity of the permissionAsset to a client chain so they can submit requests.

Requests are generated by (or on behalf of) a client (leaf) chain. The request transactions are identified by having a time (blockheight) locked (\ ``OP_CLTV``\ ) permissionAsset output and a NULL ``OP_RETURN`` output with metadata. This ``OP_RETURN`` metadata is encoded as follows:

32 bytes client chain genesis block hash
4 bytes service period start time (block height)
4 bytes target number of tickets
4 bytes auction price decay constant
4 bytes fee percentage

The request transaction is generated with a new RPC: ``createrawrequesttx``. The RPC will take the arguments: 1. txid of input 2. vout of input. 3. output address 4. permission asset ID type, 5. client chain genesis block hash 6. start time (startBlockHeight) 7. end time (endBlockHeight) 8. target no. of tickets 9. auction decay constant 10. fee percentage.

The RPC will then create a new transaction. This tx will have one input (txid and vout) and two outputs. The first output will pay to the output address and have a time-lock set to the end time (block height). The first output asset ID tag will be set to RPC argument 4 (permission asset ID type). The first output script can be constructed like: ``script = CScript() ToByteVector(endBlockHeight) << OP_CHECKLOCKTIMEVERIFY << OP_DROP << OP_DUP << OP_HASH160 << ToByteVector(keyID) << OP_EQUALVERIFY << OP_CHECKSIG``

The second output will just be an ``OP_RETURN/TX_NULL_DATA`` with all the other RPC arguments concatenated together.

The raw transaction generated by this RPC will then be signed with the private key of the (\ ``permissionAsset``\ ) input and braodcast. 

Active requests RPC
^^^^^^^^^^^^^^^^^^^

To view all active requests (i.e. requests that have been confirmed but not expired: ``blockheight > endBlockHeight``\ ) the ``getrequests`` RPC is used. This RPC scans the current UTXO set for request transactions (using the permission asset type) and returns details as a JSON array. 

This array contains an object for each active request. Each object contains the request metadata and the blockheight at which it was confirmed. 

e.g. 

.. code-block:: json

   [
       {
           "blockheight": 30000,
           "startBlockHeight": 40060,
           "endBlockHeight": 90000,
           "genesisBlock": "fa1c7d059dab70cddb8cb3cc7b8971d385eecea4d68bd86c5cb6d75949789ba1",
           "numTickets": 100,
           "startPrice": 100000,
           "decayConst": 1000000,
           "feePercentage": 100
       }
   ]

This RPC will be called by the Guardnode operators/interface to get current requests. If ``blockheight`` < ``startBlockHeight`` then the auction is potentially stil active. (this RPC can be modelled on existing functions like ``gettxoutsetinfo``\ )

Decay function
^^^^^^^^^^^^^^

The decay function will return the current ticket bid price (in CBT sats) for given parameters, as follows:

.. code-block:: c++

   uint64_t ticket_auction_price(uint32_t startHeight, uint32_t height, uint32_t startPrice, uint32_t decayConst) 
   {
       uint32_t t = height - startHeight;
       if(t < 0) return 0; // error code - auction not started yet
       uint64_t tp = startPrice*(1+t)/(1+t+std::pow(t,3)/decayConst);
       return tp*100000000;
   }

Given the parameters in the object above, the ticket price is shown in the figure as function of t over 4000 blocks (~ 3 days at 1min per block). 


.. raw:: html

   <p align="center">
   <img src="images/decay.png" width="530" vspace="20">
   </p>



.. raw:: html

   <p align="center">
     <b>Fig. 1.</b>: Ticket price decay function with startPrice = 100000 CBT and decayConst = 1000000.  
   </p>


Request/bid table
^^^^^^^^^^^^^^^^^

An in-memory table (\ ``rtable``\ ) will list all current requests (if the node is configured with a ``-requestlist=1`` flag). The table will be updated at each new block: new requests will be added as a block is recieved (in the ``ConnectBlock`` function) and removed when ``blockheight`` > ``endBlockHeight``\ ) e.g. with a function ``UpdateRequestList``. In the event of a node re-start, the ``rtable`` will be regenerated by scanning the UTXO set with e.g. a function ``LoadRequestList``. (This can be based on the ``UpdateFreezeList`` and ``LoadFreezeList`` functions). Each entry in the table will have all the request transaction parameters and the request transaction ``txid``. 

In addition, each request in the table will have a vector of valid bid transactions that have been recieved against the request. As valid bids are recieved, the transaction IDs are added to this vector (along with the bif block height) up to a max of ``numTickets``. A valid bid is decribed below, and are added to the vector by the ``UpdateRequestList`` function. 

So the table will look like this:

.. code-block:: json

   [
       {
           "requestTxID": "0a22fe0103a2f583f37d3feb94df941a6c90d8d0c3113548e0776f3413f33346",
           "confblockheight": 30000,
           "startBlockHeight": 40060,
           "endBlockHeight": 90000,
           "genesisBlock": "fa1c7d059dab70cddb8cb3cc7b8971d385eecea4d68bd86c5cb6d75949789ba1",
           "numTickets": 100,
           "startPrice": 100000,
           "decayConst": 1000000,
           "feePercentage": 100,

           "bids": [
               { "txid": "65eacf082247aaf0b1624539a0d7e3bb667b73211269907b0504a3b8f8ab0a22", "confheight": 30197 },
               { "txid": "af3d49ff538a9a2bcd78b924aa27f102fb391811c387e7b5b06fc034d56cd4d8", "confheight": 30261 },
               { "txid": "64c787adf54983f90be8d6a72ba9c3e2523117804b2087f8b6324ccb4b29ac0d", "confheight": 30892 },
               { "txid": "9a5afcbd6892a2b7c8b6926f764f947df2ef22bc25be4fdb743079b7a03df56f", "confheight": 31123 }
           ]
       }
   ]

A new RPC ``getrequestbids`` will output this vector of bids (with txids and block heights) for a given request transaction ID (by querying the in memory table). 

Bid transactions
^^^^^^^^^^^^^^^^

Bid transactions will be created with a new RPC ``createrawbidtx``. This will take as arguments: 1. input txid 2. input vout 3. lock height (i.e. the ``endBlockHeight`` of the request) 4. The txid of the request. 5. The bid amount (CBT). 6. Stake address (the address to which the stake will be paid back at the end of the service period) 7. Fee address (base-58 address for fee payment on the client chain). This RPC will then output a hex encoded raw unsigned bid transaction with four outputs:


#. The first output will be P2PKH (of CBT asset type)
#. The second output will be a zero value OP_RETURN with the request TxID. 
#. The third output will be a zero value OP_RETURN with the fee payment address. 
#. Transaction fee. 

The bid transaction must have the exact amount of the bid in the first output and no other spendable outputs except for the transaction fee. Therefore, the input value must be exactly the bid amount (\ ``bidAmount``\ ) plus the transaction fee - so a transaction must be specially constructed to fund the bid transaction (using either ``createrawtransaction`` or ``sendtoaddress``\ ). 

Bid transaction validity
^^^^^^^^^^^^^^^^^^^^^^^^

When a bid transaction is recieved into a block, the ``UpdateRequestList`` function will determine its validity, and if it is valid, the TxID and block height will be added to the relevant request vector in the request array/list. The validity will be determined as follows:


#. Check if transaction is encoded as a bid transaction. 
#. Read request TxID from output 2 ``OP_RETURN``. 
#. Get the ``decayConst``\ , ``startPrice``\ , ``blockheight`` (when the request transaction was confirmed), ``startBlockHeight``\ , ``endBlockHeight`` and ``numTickets`` from the request table. 
#. Check that ``endBlockHeight`` in the bid transaction time-lock CLTV is greater than or equal to the request ``endBlockHeight``. 
#. Calculate the current bid price based on the request parameters and the current blockheight with ``ticket_auction_price``. 
#. Check that the value of CBT in output 1 is greater than or equal to the current bid price. 

If valid the, bid transaction TxID and confirmation block height is added to the request TxID vector in the request table. 

Bid output policy
^^^^^^^^^^^^^^^^^

The request bid table is used for two purposes: 1. to enable the coordinator to pay client chain fees to the winning bidders, and 2. to lock the winning bid outputs for the duration of the service period. This locking is performed at the policy level, and will be implemented in a new policy function: ``IsStakeUnLocked(tx, coinsview)``. This function will evaluate each new transaction recieved by a signing node, and reject it if it returns ``false``\ , and accept to the mempool if it returns ``true``. The function will look at the inputs to the recieved transaction, and check if they are spending from any transaction ID listed as ``bids`` in the ``rtable`` - if not it will return ``true``. If they are it will check the the request ``endBlockHeight`` and confirm that the current block height is equal or greater: if so return ``true``\ , otherwise return ``false``. 

It would also allow winning bids to collect the change (if they overbid) - see the guardnode tecdoc. 
